#!/usr/local/bin/python3

import numpy as np
import pandas as pd
from logger import logger
from configuration_manager_class import ConfigurationManager
from utilities import error_exit
import collections
import sys
DEBUG_FLAG = False
ROR_STATS = [ (30.00, 9.00),(5.60, 7.70), (3.50, 0.90),  (-0.05, 0.0)]  # Stocks, Bonds, TBills, Cash
ASSET_CLASSES = {'Stocks': 800000, 
                'Bonds': 400000, 
                'TBills': 200000, 
                'Cash': 100000}
INITIAL_HOLDINGS = pd.DataFrame(ASSET_CLASSES, index=ASSET_CLASSES.keys(), columns=['Market Value'])
CASHFLOW_SERIES = pd.Series(index=range(65, 101), data=[10000] * 36, name="Cashflows")

class ArrayRandGen:
    def __init__(self,config_manager: ConfigurationManager, mean: float, stdv: float):
        self.config_manager = config_manager
        self.config = self.config_manager.get_class_config(self.__class__.__name__)
        self.nb = self.config['end_age'] - self.config['start_age'] + 1
        self.mean = mean
        self.stdv = stdv
        self.ror_floor = self.config['RoR_floor']
        self.ror_ceiling = self.config['Ror_ceiling']

    def __iter__(self):
        return self

    def __next__(self) -> list[float]:
        """
        returns a list of nb random numbers based on mean and stddev
        numbers are: 1 + random_number/100  (interest rates)
        NOTE that the RoR is clipped to the floor and ceiling to account for historical data
        """
        random_values = np.random.normal(self.mean, self.stdv, size=self.nb)
        ror_values = 1 + 0.01 * random_values
        # Clip the final RoR values to historical bounds
        ror_values = np.clip(ror_values, self.ror_floor, self.ror_ceiling)
        return ror_values.tolist()


class MontecarloSimulation:
    """
    Run Montecarlo simulation
    :param init_asset: (N,) SERIES of assets allocated by asset class
    :param ror_stats: Namedstuple keyed by asset class name with 2-tuple values
    :param cashflow_ser: Series of yearly withdrawals [or income] for each consecutive age
    :param cnt: Nb of iterations to run the simulation
    :return: [N, cnt] DF with ending amount by asset class for each simulation run

    Each process must initialize randon number generator's seed
    https://bbabenko.github.io/multiprocessing-and-seeded-RNGs/
    """


    def __init__(self, config_manager: ConfigurationManager) -> None:
        """
        Loads initial holdings - from which we compute the target asset allocation and the starting funds
        Loads the yearly cashflows by age
        Loads a DF of rates of return for each asset class for each year
        Runs the simulation for the number of iterations specified in the configuration
        """
        self.config_manager = config_manager
        self.config = self.config_manager.get_class_config(self.__class__.__name__)
        self.target_end_funds = self.config['target_end_funds']
        self.target_success_rate = self.config['target_success_rate']
        self.seed = self.config['seed']
        self.run_cnt = self.config['run_cnt']
        self.re_alloc_error = self.config['re_alloc_error']
        self.nb_cpu = self.config['nb_cpu']
        self.Funds_step = self.config['Funds_step']
        self.Discret_step = self.config['Discret_step']
        self.Success_threshold = self.config['Success_threshold']
        self.mgt_fee = self.config['mgt_fee']
        self.rebalance_flag = self.config['rebalance_flag']
        self.busted_ages = []
        self.busted_cnt = 0
        return None


    def set_initial_holdings(self, initial_holdings: pd.DataFrame) -> None:
        """Set the initial holdings DataFrame and the target asset allocation"""
        self.initial_holdings = initial_holdings
        self.start_funds = initial_holdings['Market Value'].sum()
        logger.info(f"Starting Funds: ${self.start_funds:,.2f}")
        self.target_asset_allocation = initial_holdings['Market Value'] / self.start_funds
        logger.info(f"Target Asset Allocation: {self.target_asset_allocation}")
        self.final_result_df = pd.DataFrame(index=self.initial_holdings.index, columns=range(self.run_cnt))  

        return None

    def set_cashflow_series(self, cashflow_ser: pd.Series) -> None:
        """Set the cashflow : Series of yearly cashflows by age """
        self.cashflow_ser = cashflow_ser
        self.age_lst = list(map(int, cashflow_ser.index))
        self.start_age = self.age_lst[0]
        self.end_age = self.age_lst[-1]
        self.nb_ages = len(self.age_lst)
        return None


    def mk_ror_lst(self, gen_list: list[ArrayRandGen]) -> list[list[float]]:
        """
        Generate a dataframe where columns are integers in range(start, end) - where the rates of return are 
        generated by the generators in gen_list
        :param gen_list: list of generators
        :param df_inde: df_inde of DF
        :return: pd.DataFrame with end-start columns

        """
        ror_values = []  # list of list of RoR values
        for gener in  gen_list:
            # generator returns a 1-element list which contains the list of values
            # ror_values.append(list(next(gener)))
            new_ror_values = list(next(gener))
            if DEBUG_FLAG:
                logger.debug(f"New RoR values: {new_ror_values}")
                logger.debug(f"mean: {np.mean(new_ror_values)} - ie. {100*(-1+np.mean(new_ror_values)):.2f}% , stdv: {100*np.std(new_ror_values):.2f} \n")
            ror_values.append(new_ror_values)
        # Convert the list of list of RoR values to a DataFrame
        # return pd.DataFrame(ror_values, index=idx_name, columns=list(range(start, end + 1)))
        return ror_values  # list of list of RoR values for each age


    def run_one_iter(self) -> (pd.DataFrame, bool, int):
        """Run one iteration of the simulation
        """
        portfolio_df = self.initial_holdings.copy(deep=True)
        busted_flag = False
        busted_age = self.end_age + 1

        mk_lst_lst = self.mk_ror_lst(self.ror_gen_list) # list of list of RoR values for each age
        for age, ror_lst, cashflow_val in zip(self.age_lst, mk_lst_lst, self.cashflow_ser):
            new_portfolio_df, busted_flag = self.run_one_year(portfolio_df, ror_lst, cashflow_val)
            self.busted_ages.append(busted_age)
            if busted_flag:
                self.busted_cnt += 1
                break  # Stop iterating over age when we bust out
            else:
                portfolio_df = new_portfolio_df
        return portfolio_df, busted_flag, busted_age

    def run_one_year(self, portfolio_df: pd.DataFrame, ror_lst: list[float], cashflow_val: float) -> (pd.DataFrame, bool):
        """Run one year of the simulation
        Note the order of operations is important 

        1. Compute the returns for the year
        2. Compute the management fee based on the portfolio value
        3. Subtract the management fee and the cashflow from the portfolio value - this can make the total portfolio value negative
        4. Determine if the portfolio is busted (negative total) - if so, return the busted flag (true)  
        5. If the portfolio is not busted, rebalance the portfolio based on rebalance flag, and
        return the portfolio and the busted flag (false)
        """
        print(f"ror_lst: {ror_lst}")
        print(f"portfolio_df: {portfolio_df}")
        pfolio_df = portfolio_df.mul(ror_lst, axis=0)  # add the returns to the portfolio
        print(f"pfolio_df: {pfolio_df}")
        pfolio_value   = pfolio_df['Market Value'].sum()   # always positive - RoR cannot be > 100%
        management_fee_value = pfolio_value * self.mgt_fee
        wdrwl_value = cashflow_val + management_fee_value  # money going out
        adjusted_pfolio_value -= wdrwl_value

        if adjusted_pfolio_value <= 0.0:  # withdrawls are greater than the portfolio value
            pfolio_df = pfolio_df * adjusted_pfolio_value / pfolio_value
            return pfolio_df, True  # Busted - note pfolio_df is not updated
        else:
            # Rebalance the portfolio based on rebalance flag
            if self.rebalance_flag:
                pfolio_df = self.target_asset_allocation * adjusted_pfolio_value
            else:
                pfolio_df = pfolio_df * adjusted_pfolio_value / pfolio_value
            return pfolio_df, False


    def xx_rebalance(self, portfolio_df: pd.DataFrame, rebalance_flag: bool) -> (pd.DataFrame, bool):
        """ Re-balance the portfolio based on the desired asset allocation
        Re-balance the portfolio based on the desired asset allocation
        :param portfolio_df: DataFrame of portfolio values
        :param rebalance_flag: boolean flag to indicate if rebalancing is desired
        :return: new values of portfolio

        Note: this needs to be performed AFTER taking 
        """
        portfolio_value = portfolio_df['Market Value'].sum()
        if portfolio_value <= 0.0:
            return portfolio_df, True

        # check that no values are negative
        if any(portfolio_df['Market Value'] < 0.0):
            error_exit(f"Negative portfolio value: {portfolio_value}")

        if self.rebalance_flag:
            # Re-allocate the portfolio based on the desired asset allocation
            new_portfolio_df = portfolio_value * self.target_asset_allocation
            return new_portfolio_df, False
        else:
            return portfolio_df, False

   
    def xx_re_allocate(asset, alloc, re_alloc_error):
        """
        Re-allocate assets based on desired asset allocation "alloc" - when asset amounts are negative
        :param asset: Series of assets
        :param alloc: Target allocation
        :return: new values of asset
        """
        if all(asset >= 0.0):  # all good, all amounts are positive or zero
            return asset, alloc  # done
        if asset.sum() <= 0.0:  # Busted - sum of amounts are negative or 0 -> return all 0s
            return pd.Series(0, index=np.arange(len(asset))), alloc

        # Need to make adjustments
        n_asset = asset.copy(deep=True)
        n_alloc = alloc.copy(deep=True)
        # Need to iterate until all asset classes are positive or zero
        neg_flag = n_asset < 0.0
        while any(neg_flag):  # While one asset category is negative
            # Some = but not all - assets have negative amount
            to_re_allocate = n_asset[neg_flag].sum()  # sum of all negative amounts
            n_asset[neg_flag] = 0.0  # zero out assets that have no money
            n_alloc[neg_flag] = 0.0  # zero out allocation of asset that have no money
            tot = n_alloc.sum()  # will be < 1.0
            n_alloc = (n_alloc / tot)  # rebalance allocations for classes that have positive amount
            assert (abs(n_alloc.sum() - 1.0) < re_alloc_error),\
                "n_alloc adds up to {:,.4f} - not 1.0 - n_alloc:\n".format(n_alloc.sum()) + str(n_alloc)
            adjust = (n_alloc * to_re_allocate)  # distribute amount to re-allocate among assets still active
            n_asset += adjust
            neg_flag = (n_asset < 0.0)  # Re-test - some asset classes may have become negative after rebalancing
            if abs(asset.sum() - n_asset.sum()) > re_alloc_error:
                logger.info(
                            "Asset {:,.4f} and re-allocated assets {:,.4f} don't add up - delta = {:,.8f}".format(asset.sum(),
                                n_asset.sum(), asset.sum() - n_asset.sum()))
        return n_asset, n_alloc
    
    def xx_run_mc_multi(init_asset, big_ror_df, cashflow_df, mgt_fee, rebal_flag, cnt, offset, test_param=None):
        """
        Run Montecarlo simulation
        @param init_asset: (N,) SERIES of assets allocated by asset class
        @param big_ror_df: Large array of rates of returns (ror) for each kind of asset - pseudo-random based on each asset's stats
        @param cashflow_df: Series of yearly withdrawals [or income] for each consecutive age
        @param cnt: Nb of iterations to run the simulation
        @param offset: offset in big_ror_df from which to extract ror for each iteration - used in parallel processing
        @return: [N, cnt] DF with 2-uple (DF of ending amount by asset class for each simulation run, end age]
        """
        # print('run_mc_multi: pid: {}, cnt= {}, offset={}'.format(os.getpid(), cnt, offset))
        age_col = list(map(int, cashflow_df.index))
        ages = (int(age_col[0]), int(age_col[-1]))  # start and end age
        nb_ages = ages[1] - ages[0] + 1  # We keep both start and end age
        idx_name = init_asset.index
        # Create dataframe for results - rows are asset classes, columns are iterations
        asset_df = pd.DataFrame(index=idx_name, dtype=float, columns=range(cnt))
        # Create final_age series [N] - initialized to 0
        final_age_ser = pd.Series([0] * cnt, index=range(cnt), dtype=int)
        # Compute asset allocation - and use it for rebalancing
        asset_alloc = init_asset / init_asset.sum()  # Fraction
        # assert asset_alloc.sum() == 1.0, f'Asset allocation (= {asset_alloc.sum():,.6f}) must add up to 1.0'
        assert abs(asset_alloc.sum() - 1.0) < 1e-6, f'Asset allocation (= {asset_alloc.sum():,.6f}) must add up to 1.0'
        # Convert cashflow_df from DF with 1 column of label 0 to Series
        cashflow_ser = pd.Series(cashflow_df[0])

        # set straight_distribution_flag if we are in test mode
        straight_distribution_flag = False
        if test_param:
            if test_param['straight_distribution']:
                straight_distribution_flag = True

        # Select the function for asset update
        if not straight_distribution_flag:
            if rebal_flag:
                update_asset_val = update_asset_val_w_rebalance
            else:
                update_asset_val = update_asset_val_no_rebalance
        else:  # straight_distribution - NO rebalance
            update_asset_val = update_asset_val_straight

        # Run nb_iter simulations
        for nb_iter in range(cnt):
            asset_val = init_asset.copy(deep=True)  # initialize
            # Generate a new array of rate of returns for all ages and each asset class
            ror_df = mk_ror_df(big_ror_df, nb_iter, ages, offset)

            # Update asset values at each age
            busted_age = 200
            for age in age_col:
                asset_val = update_asset_val(asset_val, ror_df[age], cashflow_ser[age], asset_alloc, mgt_fee)
                if asset_val.sum() < 0.0:  # Busted
                    # print('Busted! @iter: {:d} - age {:d}'.format(nb_iter, int(age)))
                    busted_age = age
                    break  # Stop iterating over age
            # store final result of this simulation run
            asset_df[nb_iter] = asset_val
            final_age_ser[nb_iter] = busted_age

        return asset_df, final_age_ser

    def run(self) -> None:
        # print("run_mc_multi: pid: {}, cnt= {}, seed={}".format(os.getpid(), cnt, seed))
        np.random.seed(self.seed)
        for itr in range(self.run_cnt):
            final_portfolio_df, busted_flag, busted_age = self.run_one_iter()

        # create a series for the final portfolio values
        final_result_series = self.final_result_df.sum(axis=1)
        # Compute statistics on the final portfolio values
        final_result_series_stats = final_result_series.describe()
        logger.info(f"Final result  stats:\n{final_result_series_stats}")

        # Create a dict that counts the number of busted ages
        busted_ages_dict = dict(collections.Counter(self.busted_ages))
        logger.info(f"Busted ages dict: {busted_ages_dict}")
        # Compute confidence level
        confidence_level = 100.0 * (self.run_cnt - self.busted_cnt) / self.run_cnt
        logger.info(f"Confidence level: {confidence_level:.2f}%")

        return

if __name__ == "__main__":
    config_manager = ConfigurationManager(sys.argv)
    montecarlo_simulation = MontecarloSimulation(config_manager)
    montecarlo_simulation.set_initial_holdings(INITIAL_HOLDINGS)   
    montecarlo_simulation.set_cashflow_series(CASHFLOW_SERIES)
    montecarlo_simulation.mk_ror_lst()
    montecarlo_simulation.run()
    sys.exit("---\nDone!")