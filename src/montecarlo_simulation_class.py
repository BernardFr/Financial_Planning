import numpy as np
import pandas as pd
from logger import logger
from configuration_manager_class import ConfigurationManager
from start_end_ages_class import StartEndAges

class ArrayRandGen:
    def __init__(self, ages, stats):
        self.nb = ages[1] - ages[0] + 1
        self.mean = stats[0]
        self.stdv = stats[1]

    def __iter__(self):
        return self

    def __next__(self):
        # returns a list of nb random numbers based on mean and stddev
        # numbers are: 1 + random_number/100  (interest rates)
        yield [
            1 + 0.01 * np.random.normal(self.mean, self.stdv) for _ in range(self.nb)
        ]


class MontecarloSimulation:
    """
    Run Montecarlo simulation
    :param init_asset: (N,) SERIES of assets allocated by asset class
    :param ror_stats: Namedstuple keyed by asset class name with 2-tuple values
    :param cashflow_ser: Series of yearly withdrawals [or income] for each consecutive age
    :param cnt: Nb of iterations to run the simulation
    :return: [N, cnt] DF with ending amount by asset class for each simulation run

    Each process must initialize randon number generator's seed
    https://bbabenko.github.io/multiprocessing-and-seeded-RNGs/
    """


    def __init__(self, config_manager: ConfigurationManager):
        self.config_manager = config_manager
        self.config = self.config_manager.get_class_config(self.__class__.__name__)
        self.init_asset = self.config['INIT_ASSET']
        self.ror_stats = self.config['ROR_STATS']
        self.cashflow_ser = self.config['CASHFLOW_SER']
        self.re_alloc_error = self.config['RE_ALLOC_ERROR']
        self.cnt = self.config['CNT']
        self.seed = self.config['SEED']

    def _mk_ror_df(gen_list, index):
        """
        Generate a dataframe where columns are integers in range(start, end) - where the rates of return are 
        generated by the generators in gen_list
        :param gen_list: list of generators
        :param index: index of DF
        :return: pd.DataFrame with end-start columns

        Start and end ages are obtained from StartEndAges class
        """
        start, end = StartEndAges.start_end_ages.get_start_end_ages()
        df = pd.DataFrame(
            data=None, index=index, columns=list(range(start, end + 1)), dtype=float
        )
        for idx, gener in zip(list(index), gen_list):
            # generator returns a 1-element list which contains the list of values
            df.loc[idx] = list(next(gener))[0]
        return df

    def _re_allocate(asset, alloc, re_alloc_error):
        """
        Re-allocate assets based on desired asset allocation "alloc" - when asset amounts are negative
        :param asset: Series of assets
        :param alloc: Target allocation
        :return: new values of asset
        """
        if all(asset >= 0.0):  # all good, all amounts are positive or zero
            return asset, alloc  # done
        if asset.sum() <= 0.0:  # Busted - sum of amounts are negative or 0 -> return all 0s
            return pd.Series(0, index=np.arange(len(asset))), alloc

        # Need to make adjustments
        n_asset = asset.copy(deep=True)
        n_alloc = alloc.copy(deep=True)
        # Need to iterate until all asset classes are positive or zero
        neg_flag = n_asset < 0.0
        while any(neg_flag):  # While one asset category is negative
            # Some = but not all - assets have negative amount
            to_re_allocate = n_asset[neg_flag].sum()  # sum of all negative amounts
            n_asset[neg_flag] = 0.0  # zero out assets that have no money
            n_alloc[neg_flag] = 0.0  # zero out allocation of asset that have no money
            tot = n_alloc.sum()  # will be < 1.0
            n_alloc = (n_alloc / tot)  # rebalance allocations for classes that have positive amount
            assert (abs(n_alloc.sum() - 1.0) < re_alloc_error),\
                "n_alloc adds up to {:,.4f} - not 1.0 - n_alloc:\n".format(n_alloc.sum()) + str(n_alloc)
            adjust = (n_alloc * to_re_allocate)  # distribute amount to re-allocate among assets still active
            n_asset += adjust
            neg_flag = (n_asset < 0.0)  # Re-test - some asset classes may have become negative after rebalancing
            if abs(asset.sum() - n_asset.sum()) > re_alloc_error:
                logger.info(
                            "Asset {:,.4f} and re-allocated assets {:,.4f} don't add up - delta = {:,.8f}".format(asset.sum(),
                                n_asset.sum(), asset.sum() - n_asset.sum()))
        return n_asset, n_alloc


    def run(self):
        # print("run_mc_multi: pid: {}, cnt= {}, seed={}".format(os.getpid(), cnt, seed))
        np.random.seed(self.seed)
        age_col = list(self.cashflow_ser.index)
        ages = (int(age_col[0]), int(age_col[-1]))  # start and end age
        idx_name = self.init_asset.index
        ror_gen_list = [ArrayRandGen(ages, a) for a in self.ror_stats]  # List of generators
        # Create dataframe for results - rows are asset classes, columns are iterations
        asset_df = pd.DataFrame(index=idx_name, dtype=float)  # Empty DF with the right index
        # Compute initial asset allocation - and use it for rebalancing
        init_alloc = self.init_asset / self.init_asset.sum()
        busted_ages = []
        for itr in range(self.cnt):
            asset_tmp = self.init_asset.copy(deep=True)  # initialize
            wdrwl_alloc = init_alloc  # Initial allocation of withdrawals
            # Generate a new array of rate of returns for all ages and each asset class
            ror_df = self.mk_ror_df(ror_gen_list, idx_name, ages)
            for age in age_col:
                # Compute returns of existing assets and allocate year's withdrawal weighted to available assets
                asset_tmp = asset_tmp * ror_df[age] + wdrwl_alloc * self.cashflow_ser[age]
                if asset_tmp.sum() <= 0.0:  # Busted: no more money
                    # logger.info('Busted! @iter: {:d} - age {:d}'.format(iter, int(age)))
                    busted_ages += [age]
                    break  # Stop iterating over age
                else:
                    n_asset, wdrwl_alloc = self._re_allocate(asset_tmp, wdrwl_alloc, self.re_alloc_error)
                    assert (
                        abs(asset_tmp.sum() - n_asset.sum()) < self.re_alloc_error
                    ), "Asset {:,.4f} and re-allocated assets {:,.4f} don't add up - delta = {:,.8f}\n, iter={:d} - age={:d}".format(
                        asset_tmp.sum(), n_asset.sum(), asset_tmp.sum() - n_asset.sum(), itr, age,)
                    asset_tmp = n_asset
            # asset_df[iter] = asset_tmp  # store final result of this simulation run
            asset_tmp.name = itr
            asset_df = pd.concat([asset_df, asset_tmp], axis=1)  # store final result of this simulation run
        return asset_df, busted_ages
