import numpy as np
import pandas as pd
from logger import logger
from configuration_manager_class import ConfigurationManager

# See ReadMe - historically, S&P 500 has a floor of -47% and a ceiling of 53% - we will use a max of +/- 40% for RoR
ROR_FLOOR = 0.60  # corresponds to a -40% RoR
ROR_CEILING = 1.40  # corresponds to a +40% RoR

class ArrayRandGen:
    def __init__(self, ages, stats):
        self.nb = ages[1] - ages[0] + 1
        self.mean = stats[0]
        self.stdv = stats[1]

    def __iter__(self):
        return self

    def __next__(self):
        # returns a list of nb random numbers based on mean and stddev
        # numbers are: 1 + random_number/100  (interest rates)
        # Note that the RoR is clipped to the floor and ceiling to account for historical data
        # Best practice: Generate all values at once, then clip the final RoR values
        random_values = np.random.normal(self.mean, self.stdv, size=self.nb)
        ror_values = 1 + 0.01 * random_values
        # Clip the final RoR values to historical bounds using np.clip() - best for arrays
        ror_values = np.clip(ror_values, ROR_FLOOR, ROR_CEILING)
        # Convert to list to match expected return type
        yield [ror_values.tolist()]

def mk_ror_df(gen_list: list[ArrayRandGen], start: int, end: int, df_index: list[str]) -> pd.DataFrame:
    """
    Generate a dataframe where columns are integers in range(start, end) - where the rates of return are 
    generated by the generators in gen_list
    :param gen_list: list of generators
    :param df_inde: df_inde of DF
    :return: pd.DataFrame with end-start columns

    """

    df = pd.DataFrame(index=df_index, columns=list(range(start, end + 1)), dtype=float)
    for idx, gener in zip(list(df_index), gen_list):
        # generator returns a 1-element list which contains the list of values
        df.loc[idx] = list(next(gener))[0]
    return df


class MontecarloSimulation:
    """
    Run Montecarlo simulation
    :param init_asset: (N,) SERIES of assets allocated by asset class
    :param ror_stats: Namedstuple keyed by asset class name with 2-tuple values
    :param cashflow_ser: Series of yearly withdrawals [or income] for each consecutive age
    :param cnt: Nb of iterations to run the simulation
    :return: [N, cnt] DF with ending amount by asset class for each simulation run

    Each process must initialize randon number generator's seed
    https://bbabenko.github.io/multiprocessing-and-seeded-RNGs/
    """


    def __init__(self, config_manager: ConfigurationManager) -> None:
        """
        Loads initial holdings - from which we compute the target asset allocation and the starting funds
        Loads the yearly cashflows by age
        Loads a DF of rates of return for each asset class for each year
        Runs the simulation for the number of iterations specified in the configuration
        """
        self.config_manager = config_manager
        self.config = self.config_manager.get_class_config(self.__class__.__name__)
        self.target_end_funds = self.config['target_end_funds']
        self.target_success_rate = self.config['target_success_rate']
        self.seed = self.config['seed']
        self.run_cnt = self.config['run_cnt']
        self.Max_iter = self.config['Max_iter']
        self.re_alloc_error = self.config['re_alloc_error']
        self.nb_cpu = self.config['nb_cpu']
        self.Funds_step = self.config['Funds_step']
        self.Discret_step = self.config['Discret_step']
        self.Success_threshold = self.config['Success_threshold']
        self.mgt_fee = self.config['mgt_fee']
        return None


    def set_initial_holdings(self, initial_holdings: pd.DataFrame) -> None:
        """Set the initial holdings DataFrame and the target asset allocation"""
        self.initial_holdings = initial_holdings
        self.start_funds = initial_holdings['Market Value'].sum()
        logger.info(f"Starting Funds: ${self.start_funds:,.2f}")
        self.target_asset_allocation = initial_holdings['Market Value'] / self.start_funds
        logger.info(f"Target Asset Allocation: {self.target_asset_allocation}")

        return None

    def set_cashflow_series(self, cashflow_ser: pd.Series) -> None:
        """Set the cashflow : Series of yearly cashflows by age """
        self.cashflow_ser = cashflow_ser
        self.age_lst = list(map(int, cashflow_ser.index))
        self.start_age = self.age_lst[0]
        self.end_age = self.age_lst[-1]
        self.nb_ages = len(self.age_lst)
        return None

    def set_ror_df(self, ror_df: pd.DataFrame) -> None:
        """Set the rates of return DataFrame"""
        self.ror_df = ror_df
        return None

    def run_one_iter(self, ror_df: pd.DataFrame) -> None:
        """Run one iteration of the simulation"""
        portfolio_df = self.initial_holdings.copy(deep=True)
        busted_flag = False
        busted_age = self.end_age + 1
        # convert ror_df to a list of series, one for each age/column
        ror_ser_lst = [ror_df[age] for age in self.age_lst]
        for age, ror_ser, cashflow_val in zip(self.age_lst, ror_ser_lst, self.cashflow_ser):
            portfolio_value = portfolio_df['Market Value'].sum()
            new_portfolio_df = portfolio_df * ror_ser  # add the returns to the portfolio
            management_fee_value = portfolio_value * self.mgt_fee
            distribution_value = cashflow_val + management_fee_value  # money going out
            # Make a vector where the distribution is distributed to the portfolio proportionally to the market value of each asset
            distribution_vector = portfolio_df['Market Value'] / portfolio_value
            new_portfolio_df -= distribution_vector * distribution_value
            # Rebalance the portfolio
            new_portfolio_df = new_portfolio_df / new_portfolio_df.sum()
            portfolio_df = new_portfolio_df
            if new_portfolio_df['Market Value'].sum() <= 0.0:
                busted_flag = True
                busted_age = age
                break  # Stop iterating over age when we bust out
            else:
                portfolio_df = new_portfolio_df
        return portfolio_df, busted_flag, busted_age

            busted_flag, asset_value = self.run_one_year(asset_value, ror_df[age], age)
            if busted_flag:
                busted_age = age
                break  # Stop iterating over age when we bust out
            else:
            # Run one year
            delta_asset = asset_now * ror + self.flow_ser[age] - asset_now * self.management_fee
            asset_eoy = asset_now + delta_asset
            # if DEBUG:
            #     print(
            #         f"Age: {age} - asset in: {asset_now:,.2f} - asset out: {asset_eoy:,.2f} - delta: {delta_asset:,.2f}")
            busted_flag = True if asset_eoy <= 0.0 else False  # we're busted if total assets are negative
            return busted_flag, asset_eoy

        return None



    def _re_allocate(asset, alloc, re_alloc_error):
        """
        Re-allocate assets based on desired asset allocation "alloc" - when asset amounts are negative
        :param asset: Series of assets
        :param alloc: Target allocation
        :return: new values of asset
        """
        if all(asset >= 0.0):  # all good, all amounts are positive or zero
            return asset, alloc  # done
        if asset.sum() <= 0.0:  # Busted - sum of amounts are negative or 0 -> return all 0s
            return pd.Series(0, index=np.arange(len(asset))), alloc

        # Need to make adjustments
        n_asset = asset.copy(deep=True)
        n_alloc = alloc.copy(deep=True)
        # Need to iterate until all asset classes are positive or zero
        neg_flag = n_asset < 0.0
        while any(neg_flag):  # While one asset category is negative
            # Some = but not all - assets have negative amount
            to_re_allocate = n_asset[neg_flag].sum()  # sum of all negative amounts
            n_asset[neg_flag] = 0.0  # zero out assets that have no money
            n_alloc[neg_flag] = 0.0  # zero out allocation of asset that have no money
            tot = n_alloc.sum()  # will be < 1.0
            n_alloc = (n_alloc / tot)  # rebalance allocations for classes that have positive amount
            assert (abs(n_alloc.sum() - 1.0) < re_alloc_error),\
                "n_alloc adds up to {:,.4f} - not 1.0 - n_alloc:\n".format(n_alloc.sum()) + str(n_alloc)
            adjust = (n_alloc * to_re_allocate)  # distribute amount to re-allocate among assets still active
            n_asset += adjust
            neg_flag = (n_asset < 0.0)  # Re-test - some asset classes may have become negative after rebalancing
            if abs(asset.sum() - n_asset.sum()) > re_alloc_error:
                logger.info(
                            "Asset {:,.4f} and re-allocated assets {:,.4f} don't add up - delta = {:,.8f}".format(asset.sum(),
                                n_asset.sum(), asset.sum() - n_asset.sum()))
        return n_asset, n_alloc
    
    def run_mc_multi(init_asset, big_ror_df, cashflow_df, mgt_fee, rebal_flag, cnt, offset, test_param=None):
        """
        Run Montecarlo simulation
        @param init_asset: (N,) SERIES of assets allocated by asset class
        @param big_ror_df: Large array of rates of returns (ror) for each kind of asset - pseudo-random based on each asset's stats
        @param cashflow_df: Series of yearly withdrawals [or income] for each consecutive age
        @param cnt: Nb of iterations to run the simulation
        @param offset: offset in big_ror_df from which to extract ror for each iteration - used in parallel processing
        @return: [N, cnt] DF with 2-uple (DF of ending amount by asset class for each simulation run, end age]
        """
        # print('run_mc_multi: pid: {}, cnt= {}, offset={}'.format(os.getpid(), cnt, offset))
        age_col = list(map(int, cashflow_df.index))
        ages = (int(age_col[0]), int(age_col[-1]))  # start and end age
        nb_ages = ages[1] - ages[0] + 1  # We keep both start and end age
        idx_name = init_asset.index
        # Create dataframe for results - rows are asset classes, columns are iterations
        asset_df = pd.DataFrame(index=idx_name, dtype=float, columns=range(cnt))
        # Create final_age series [N] - initialized to 0
        final_age_ser = pd.Series([0] * cnt, index=range(cnt), dtype=int)
        # Compute asset allocation - and use it for rebalancing
        asset_alloc = init_asset / init_asset.sum()  # Fraction
        # assert asset_alloc.sum() == 1.0, f'Asset allocation (= {asset_alloc.sum():,.6f}) must add up to 1.0'
        assert abs(asset_alloc.sum() - 1.0) < 1e-6, f'Asset allocation (= {asset_alloc.sum():,.6f}) must add up to 1.0'
        # Convert cashflow_df from DF with 1 column of label 0 to Series
        cashflow_ser = pd.Series(cashflow_df[0])

        # set straight_distribution_flag if we are in test mode
        straight_distribution_flag = False
        if test_param:
            if test_param['straight_distribution']:
                straight_distribution_flag = True

        # Select the function for asset update
        if not straight_distribution_flag:
            if rebal_flag:
                update_asset_val = update_asset_val_w_rebalance
            else:
                update_asset_val = update_asset_val_no_rebalance
        else:  # straight_distribution - NO rebalance
            update_asset_val = update_asset_val_straight

        # Run nb_iter simulations
        for nb_iter in range(cnt):
            asset_val = init_asset.copy(deep=True)  # initialize
            # Generate a new array of rate of returns for all ages and each asset class
            ror_df = mk_ror_df(big_ror_df, nb_iter, ages, offset)

            # Update asset values at each age
            busted_age = 200
            for age in age_col:
                asset_val = update_asset_val(asset_val, ror_df[age], cashflow_ser[age], asset_alloc, mgt_fee)
                if asset_val.sum() < 0.0:  # Busted
                    # print('Busted! @iter: {:d} - age {:d}'.format(nb_iter, int(age)))
                    busted_age = age
                    break  # Stop iterating over age
            # store final result of this simulation run
            asset_df[nb_iter] = asset_val
            final_age_ser[nb_iter] = busted_age

        return asset_df, final_age_ser



    def run(self):
        # print("run_mc_multi: pid: {}, cnt= {}, seed={}".format(os.getpid(), cnt, seed))
        np.random.seed(self.seed)
        age_col = list(self.cashflow_ser.index)
        ages = (int(age_col[0]), int(age_col[-1]))  # start and end age
        idx_name = self.init_asset.index
        ror_gen_list = [ArrayRandGen(ages, a) for a in self.ror_stats]  # List of generators
        # Create dataframe for results - rows are asset classes, columns are iterations
        asset_df = pd.DataFrame(index=idx_name, dtype=float)  # Empty DF with the right index
        # Compute initial asset allocation - and use it for rebalancing
        init_alloc = self.init_asset / self.init_asset.sum()
        busted_ages = []
        for itr in range(self.cnt):
            asset_tmp = self.init_asset.copy(deep=True)  # initialize
            wdrwl_alloc = init_alloc  # Initial allocation of withdrawals
            # Generate a new array of rate of returns for all ages and each asset class
            ror_df = self.mk_ror_df(ror_gen_list, ages[0], ages[1], idx_name)
            for age in age_col:
                # Compute returns of existing assets and allocate year's withdrawal weighted to available assets
                asset_tmp = asset_tmp * ror_df[age] + wdrwl_alloc * self.cashflow_ser[age]
                if asset_tmp.sum() <= 0.0:  # Busted: no more money
                    # logger.info('Busted! @iter: {:d} - age {:d}'.format(iter, int(age)))
                    busted_ages += [age]
                    break  # Stop iterating over age
                else:
                    n_asset, wdrwl_alloc = self._re_allocate(asset_tmp, wdrwl_alloc, self.re_alloc_error)
                    assert (
                        abs(asset_tmp.sum() - n_asset.sum()) < self.re_alloc_error
                    ), "Asset {:,.4f} and re-allocated assets {:,.4f} don't add up - delta = {:,.8f}\n, iter={:d} - age={:d}".format(
                        asset_tmp.sum(), n_asset.sum(), asset_tmp.sum() - n_asset.sum(), itr, age,)
                    asset_tmp = n_asset
            # asset_df[iter] = asset_tmp  # store final result of this simulation run
            asset_tmp.name = itr
            asset_df = pd.concat([asset_df, asset_tmp], axis=1)  # store final result of this simulation run
        return asset_df, busted_ages
